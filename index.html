<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Infinite Board PRO v2.1</title>
    <style>
        :root { --bg: #f0f0f0; --panel: #ffffff; --accent: #007bff; --text: #333; --danger: #dc3545; }
        [data-theme="dark"] { --bg: #1a1a1a; --panel: #333; --accent: #007bff; --text: #eee; }

        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: var(--bg); font-family: sans-serif; transition: 0.3s; touch-action: none; }
        
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; pointer-events: none; z-index: 100; display: flex; flex-direction: column; align-items: center; }
        .panel { 
            pointer-events: auto; background: var(--panel); padding: 8px 15px; 
            border-radius: 30px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
            display: flex; gap: 8px; align-items: center; margin: 10px;
            border: 1px solid rgba(0,0,0,0.1);
        }

        button { 
            background: #eee; border: none; padding: 8px 12px; border-radius: 20px; 
            cursor: pointer; font-size: 14px; transition: 0.2s; color: #333; white-space: nowrap;
        }
        [data-theme="dark"] button { background: #444; color: #eee; }
        button.active { background: var(--accent) !important; color: white !important; }
        button.danger { background: #ffeded; color: var(--danger); }
        [data-theme="dark"] button.danger { background: #4a2b2b; color: #ff8080; }
        
        canvas { display: block; }

        #text-input {
            position: fixed; display: none; background: white; border: 2px solid var(--accent);
            z-index: 1000; outline: none; padding: 5px; min-width: 100px; color: black; font-size: 18px;
        }
    </style>
</head>
<body data-theme="light">

<div id="ui-layer">
    <div class="panel">
        <button onclick="toggleTheme()">üåì</button>
        <button id="mode-move" class="active" onclick="setMode('move')">üñêÔ∏è –î–≤–∏–≥–∞—Ç—å</button>
        <button id="mode-draw" onclick="setMode('draw')">‚úèÔ∏è –†–∏—Å–æ–≤–∞—Ç—å</button>
        <button id="mode-text" onclick="setMode('text')">TXT –¢–µ–∫—Å—Ç</button>
        <hr style="width:1px; height:20px; border:none; background:#ccc;">
        <input type="file" id="file-input" hidden accept="image/*,video/*" onchange="handleFile(event)">
        <button onclick="document.getElementById('file-input').click()">‚ûï –ú–µ–¥–∏–∞</button>
        <button class="danger" onclick="deleteSelected()">üóëÔ∏è –û–±—ä–µ–∫—Ç</button>
        <button class="danger" onclick="clearBoard()">üí£ –û—á–∏—Å—Ç–∏—Ç—å</button>
    </div>
</div>

<div id="text-input" contenteditable="true"></div>
<canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const textInput = document.getElementById('text-input');

    let state = {
        mode: 'move',
        theme: 'light',
        camera: { x: window.innerWidth/2, y: window.innerHeight/2, zoom: 1 },
        objects: [], // –ö–∞—Ä—Ç–∏–Ω–∫–∏, –≤–∏–¥–µ–æ, —Ç–µ–∫—Å—Ç
        lines: [],   // –†–∏—Å—É–Ω–∫–∏ –∫–∏—Å—Ç—å—é
        selectedObj: null,
        isDragging: false,
        isResizing: false,
        isDrawing: false,
        lastMouse: { x: 0, y: 0 },
        textWorldPos: null
    };

    function init() {
        window.addEventListener('resize', resize);
        resize();
        render();
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        render();
    }

    function setMode(m) {
        state.mode = m;
        document.querySelectorAll('.panel button').forEach(b => b.classList.remove('active'));
        const btn = document.getElementById('mode-' + m);
        if(btn) btn.classList.add('active');
        state.selectedObj = null;
        render();
    }

    function getWorldPos(e) {
        return {
            x: (e.clientX - state.camera.x) / state.camera.zoom,
            y: (e.clientY - state.camera.y) / state.camera.zoom
        };
    }

    // --- –§–ê–ô–õ–´ ---
    function handleFile(e) {
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        const pos = { x: -state.camera.x/state.camera.zoom + 100, y: -state.camera.y/state.camera.zoom + 100 };

        if (file.type.startsWith('image')) {
            const img = new Image();
            img.src = url;
            img.onload = () => {
                state.objects.push({ type: 'image', x: pos.x, y: pos.y, w: img.width/2, h: img.height/2, el: img });
                render();
            };
        } else if (file.type.startsWith('video')) {
            const video = document.createElement('video');
            video.src = url; video.muted = false; video.loop = true;
            video.onloadeddata = () => {
                state.objects.push({ type: 'video', x: pos.x, y: pos.y, w: 320, h: 180, el: video });
                render();
            };
        }
    }

    // --- –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–ï ---
    canvas.onpointerdown = (e) => {
        const mouse = { x: e.clientX, y: e.clientY };
        const world = getWorldPos(e);
        state.lastMouse = mouse;

        if (state.mode === 'draw') {
            state.isDrawing = true;
            state.lines.push({ points: [world], color: state.theme === 'light' ? '#000' : '#fff' });
            return;
        }

        if (state.mode === 'text') {
            showTextInput(e.clientX, e.clientY, world);
            return;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ —É–∑–µ–ª –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ (–º–∞–ª–µ–Ω—å–∫–∏–π –∫–≤–∞–¥—Ä–∞—Ç –≤ —É–≥–ª—É)
        if (state.selectedObj) {
            const handleSize = 15 / state.camera.zoom;
            const cornerX = state.selectedObj.x + state.selectedObj.w;
            const cornerY = state.selectedObj.y + state.selectedObj.h;
            if (world.x > cornerX - handleSize && world.x < cornerX + handleSize &&
                world.y > cornerY - handleSize && world.y < cornerY + handleSize) {
                state.isResizing = true;
                return;
            }
        }

        // –í—ã–±–æ—Ä –æ–±—ä–µ–∫—Ç–∞ (—Å –∫–æ–Ω—Ü–∞ –º–∞—Å—Å–∏–≤–∞, —á—Ç–æ–±—ã –±—Ä–∞—Ç—å –≤–µ—Ä—Ö–Ω–∏–π)
        const hit = [...state.objects].reverse().find(o => 
            world.x > o.x && world.x < o.x + o.w && world.y > o.y && world.y < o.y + o.h
        );

        if (hit) {
            state.selectedObj = hit;
            state.isDragging = true;
            // –ï—Å–ª–∏ —ç—Ç–æ –≤–∏–¥–µ–æ - –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º –ø–∞—É–∑—É/–ø–ª–µ–π –ø—Ä–∏ –∫–ª–∏–∫–µ
            if (hit.type === 'video' && !state.isResizing) {
                hit.el.paused ? hit.el.play() : hit.el.pause();
            }
        } else {
            state.selectedObj = null;
            state.isDragging = true; // –ë—É–¥–µ–º –¥–≤–∏–≥–∞—Ç—å –∫–∞–º–µ—Ä—É
        }
        render();
    };

    canvas.onpointermove = (e) => {
        const mouse = { x: e.clientX, y: e.clientY };
        const world = getWorldPos(e);
        const dx = (mouse.x - state.lastMouse.x) / state.camera.zoom;
        const dy = (mouse.y - state.lastMouse.y) / state.camera.zoom;

        if (state.isDrawing) {
            state.lines[state.lines.length - 1].points.push(world);
        } else if (state.isResizing && state.selectedObj) {
            state.selectedObj.w += dx;
            state.selectedObj.h += dy;
        } else if (state.isDragging) {
            if (state.selectedObj && state.mode === 'move') {
                state.selectedObj.x += dx;
                state.selectedObj.y += dy;
            } else {
                state.camera.x += mouse.x - state.lastMouse.x;
                state.camera.y += mouse.y - state.lastMouse.y;
            }
        }
        
        state.lastMouse = mouse;
        render();
    };

    window.onpointerup = () => {
        state.isDragging = false;
        state.isResizing = false;
        state.isDrawing = false;
    };

    canvas.onwheel = (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        state.camera.zoom *= delta;
        render();
    };

    // --- –¢–ï–ö–°–¢ ---
    function showTextInput(x, y, world) {
        textInput.style.display = 'block';
        textInput.style.left = x + 'px';
        textInput.style.top = y + 'px';
        state.textWorldPos = world;
        setTimeout(() => textInput.focus(), 10);
    }

    textInput.onblur = () => {
        if (textInput.innerText.trim()) {
            state.objects.push({ 
                type: 'text', x: state.textWorldPos.x, y: state.textWorldPos.y, 
                w: 200, h: 40, data: textInput.innerText 
            });
        }
        textInput.style.display = 'none';
        textInput.innerText = '';
        render();
    };

    // --- –§–£–ù–ö–¶–ò–ò –£–ü–†–ê–í–õ–ï–ù–ò–Ø ---
    function deleteSelected() {
        if (state.selectedObj) {
            state.objects = state.objects.filter(o => o !== state.selectedObj);
            state.selectedObj = null;
            render();
        }
    }

    function clearBoard() {
        if (confirm("–£–¥–∞–ª–∏—Ç—å –≤—Å—ë —Å –¥–æ—Å–∫–∏?")) {
            state.objects = [];
            state.lines = [];
            render();
        }
    }

    function toggleTheme() {
        state.theme = state.theme === 'light' ? 'dark' : 'light';
        document.body.setAttribute('data-theme', state.theme);
        render();
    }

    // --- –†–ï–ù–î–ï–†–ò–ù–ì ---
    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // –°–µ—Ç–∫–∞
        const gridSize = 50 * state.camera.zoom;
        ctx.strokeStyle = state.theme === 'light' ? '#ddd' : '#333';
        ctx.beginPath();
        for (let x = state.camera.x % gridSize; x < canvas.width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
        for (let y = state.camera.y % gridSize; y < canvas.height; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
        ctx.stroke();

        ctx.save();
        ctx.translate(state.camera.x, state.camera.y);
        ctx.scale(state.camera.zoom, state.camera.zoom);

        // –û–±—ä–µ–∫—Ç—ã
        state.objects.forEach(obj => {
            if (obj.type === 'image' || obj.type === 'video') {
                ctx.drawImage(obj.el, obj.x, obj.y, obj.w, obj.h);
            } else if (obj.type === 'text') {
                ctx.fillStyle = state.theme === 'light' ? '#000' : '#fff';
                ctx.font = "20px sans-serif";
                ctx.fillText(obj.data, obj.x, obj.y + 20);
            }

            // –†–∞–º–∫–∞ –≤—ã–¥–µ–ª–µ–Ω–∏—è –∏ —É–∑–µ–ª –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞
            if (state.selectedObj === obj) {
                ctx.strokeStyle = '#007bff';
                ctx.lineWidth = 2 / state.camera.zoom;
                ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
                // –£–∑–µ–ª (—Å–∏–Ω–∏–π –∫–≤–∞–¥—Ä–∞—Ç–∏–∫)
                ctx.fillStyle = '#007bff';
                const s = 10 / state.camera.zoom;
                ctx.fillRect(obj.x + obj.w - s/2, obj.y + obj.h - s/2, s, s);
            }
        });

        // –õ–∏–Ω–∏–∏ —Ä–∏—Å—É–Ω–∫–∞
        state.lines.forEach(line => {
            ctx.beginPath();
            ctx.strokeStyle = line.color;
            ctx.lineWidth = 2 / state.camera.zoom;
            ctx.lineCap = 'round';
            ctx.moveTo(line.points[0].x, line.points[0].y);
            line.points.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
        });

        ctx.restore();
        
        // –ü–æ—Å—Ç–æ—è–Ω–Ω—ã–π —Ä–µ–Ω–¥–µ—Ä –¥–ª—è –≤–∏–¥–µ–æ
        if (state.objects.some(o => o.type === 'video' && !o.el.paused)) {
            requestAnimationFrame(render);
        }
    }

    init();
</script>
</body>
</html>
