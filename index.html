<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Infinite Board PRO v2.2</title>
    <style>
        :root { --bg: #f0f0f0; --panel: #ffffff; --accent: #007bff; --text: #333; --danger: #dc3545; }
        [data-theme="dark"] { --bg: #1a1a1a; --panel: #333; --accent: #007bff; --text: #eee; }

        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: var(--bg); font-family: sans-serif; transition: 0.3s; touch-action: none; }
        
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; pointer-events: none; z-index: 100; display: flex; flex-direction: column; align-items: center; }
        .panel { 
            pointer-events: auto; background: var(--panel); padding: 5px 12px; 
            border-radius: 30px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
            display: flex; gap: 6px; align-items: center; margin: 8px;
            border: 1px solid rgba(0,0,0,0.1); flex-wrap: wrap; justify-content: center;
        }

        button { 
            background: #eee; border: none; padding: 6px 10px; border-radius: 15px; 
            cursor: pointer; font-size: 13px; transition: 0.2s; color: #333;
        }
        [data-theme="dark"] button { background: #444; color: #eee; }
        button.active { background: var(--accent) !important; color: white !important; }
        button.danger { color: var(--danger); }
        
        canvas { display: block; }

        #text-input {
            position: fixed; display: none; background: white; border: 2px solid var(--accent);
            z-index: 1000; outline: none; padding: 5px; min-width: 100px; color: black; font-size: 18px;
        }
    </style>
</head>
<body data-theme="light">

<div id="ui-layer">
    <div class="panel">
        <button onclick="toggleTheme()">üåì</button>
        <button id="mode-move" class="active" onclick="setMode('move')">üñêÔ∏è –î–≤–∏–≥–∞—Ç—å</button>
        <button id="mode-draw" onclick="setMode('draw')">‚úèÔ∏è –ö–∏—Å—Ç—å</button>
        <button id="mode-eraser" onclick="setMode('eraser')">üßΩ –õ–∞—Å—Ç–∏–∫</button>
        <button id="mode-text" onclick="setMode('text')">TXT –¢–µ–∫—Å—Ç</button>
        <hr style="width:1px; height:20px; border:none; background:#ccc;">
        <input type="file" id="file-input" hidden accept="image/*,video/*" onchange="handleFile(event)">
        <button onclick="document.getElementById('file-input').click()">‚ûï –ú–µ–¥–∏–∞</button>
        <button onclick="moveZ('up')">üîº –í–≤–µ—Ä—Ö</button>
        <button onclick="moveZ('down')">üîΩ –í–Ω–∏–∑</button>
        <button class="danger" onclick="deleteSelected()">üóëÔ∏è –£–¥–∞–ª–∏—Ç—å</button>
        <button class="danger" onclick="clearBoard()">üí£ –°–±—Ä–æ—Å</button>
    </div>
</div>

<div id="text-input" contenteditable="true"></div>
<canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const textInput = document.getElementById('text-input');

    let state = {
        mode: 'move',
        theme: 'light',
        camera: { x: window.innerWidth/2, y: window.innerHeight/2, zoom: 1 },
        objects: [], lines: [],
        selectedObj: null,
        isDragging: false, isResizing: false, isDrawing: false,
        lastMouse: { x: 0, y: 0 },
        initialRatio: 1,
        textTarget: null
    };

    function init() {
        window.addEventListener('resize', resize);
        window.addEventListener('paste', handlePaste);
        resize();
        render();
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        render();
    }

    function setMode(m) {
        state.mode = m;
        document.querySelectorAll('.panel button').forEach(b => b.classList.remove('active'));
        document.getElementById('mode-' + m).classList.add('active');
        render();
    }

    function getWorldPos(e) {
        return {
            x: (e.clientX - state.camera.x) / state.camera.zoom,
            y: (e.clientY - state.camera.y) / state.camera.zoom
        };
    }

    // --- –í–°–¢–ê–í–ö–ê –ò–ó –ë–£–§–ï–†–ê (Ctrl+V) ---
    function handlePaste(e) {
        const items = e.clipboardData.items;
        for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf("image") !== -1) {
                const blob = items[i].getAsFile();
                const url = URL.createObjectURL(blob);
                const img = new Image();
                img.src = url;
                img.onload = () => addObj('image', img);
            }
        }
    }

    function handleFile(e) {
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        if (file.type.startsWith('image')) {
            const img = new Image(); img.src = url;
            img.onload = () => addObj('image', img);
        } else {
            const video = document.createElement('video'); video.src = url;
            video.muted = true; video.loop = true;
            video.onloadeddata = () => addObj('video', video);
        }
    }

    function addObj(type, el) {
        const pos = { x: -state.camera.x/state.camera.zoom + 100, y: -state.camera.y/state.camera.zoom + 100 };
        const w = type === 'image' ? el.width/2 : 320;
        const h = type === 'image' ? el.height/2 : 180;
        state.objects.push({ type, x: pos.x, y: pos.y, w, h, el, ratio: w/h });
        render();
    }

    // --- –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–ï ---
    canvas.onpointerdown = (e) => {
        const world = getWorldPos(e);
        state.lastMouse = { x: e.clientX, y: e.clientY };

        if (state.mode === 'draw' || state.mode === 'eraser') {
            state.isDrawing = true;
            if (state.mode === 'draw') {
                state.lines.push({ points: [world], color: state.theme === 'light' ? '#000' : '#fff' });
            }
            return;
        }

        if (state.mode === 'text') {
            const hitText = state.objects.find(o => o.type === 'text' && world.x > o.x && world.x < o.x + o.w && world.y > o.y - 20 && world.y < o.y + 10);
            if (hitText) {
                editExistingText(hitText, e.clientX, e.clientY);
            } else {
                showTextInput(e.clientX, e.clientY, world);
            }
            return;
        }

        // –†–µ—Å–∞–π–∑ (—Ç–æ–ª—å–∫–æ –∑–∞ —É–≥–æ–ª)
        if (state.selectedObj) {
            const s = 20 / state.camera.zoom;
            if (world.x > state.selectedObj.x + state.selectedObj.w - s && world.y > state.selectedObj.y + state.selectedObj.h - s) {
                state.isResizing = true;
                state.initialRatio = state.selectedObj.w / state.selectedObj.h;
                return;
            }
        }

        const hit = [...state.objects].reverse().find(o => world.x > o.x && world.x < o.x + o.w && world.y > o.y && world.y < o.y + o.h);
        if (hit) {
            state.selectedObj = hit;
            state.isDragging = true;
            if (hit.type === 'video' && e.pointerType === 'mouse') hit.el.paused ? hit.el.play() : hit.el.pause();
        } else {
            state.selectedObj = null;
            state.isDragging = true;
        }
        render();
    };

    canvas.onpointermove = (e) => {
        const mouse = { x: e.clientX, y: e.clientY };
        const world = getWorldPos(e);
        const dx = (mouse.x - state.lastMouse.x) / state.camera.zoom;

        if (state.isDrawing) {
            if (state.mode === 'draw') {
                state.lines[state.lines.length - 1].points.push(world);
            } else {
                // –õ–∞—Å—Ç–∏–∫: —É–¥–∞–ª—è–µ–º –ª–∏–Ω–∏–∏, –¥–æ –∫–æ—Ç–æ—Ä—ã—Ö –¥–æ–∫–æ—Å–Ω—É–ª–∏—Å—å
                state.lines = state.lines.filter(line => !line.points.some(p => Math.hypot(p.x - world.x, p.y - world.y) < 10 / state.camera.zoom));
            }
        } else if (state.isResizing && state.selectedObj) {
            state.selectedObj.w += dx;
            state.selectedObj.h = state.selectedObj.w / state.selectedObj.ratio; // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–æ–ø–æ—Ä—Ü–∏–π
        } else if (state.isDragging) {
            if (state.selectedObj && state.mode === 'move') {
                state.selectedObj.x += dx;
                state.selectedObj.y += (mouse.y - state.lastMouse.y) / state.camera.zoom;
            } else {
                state.camera.x += mouse.x - state.lastMouse.x;
                state.camera.y += mouse.y - state.lastMouse.y;
            }
        }
        state.lastMouse = mouse;
        render();
    };

    window.onpointerup = () => { state.isDrawing = false; state.isResizing = false; state.isDragging = false; };

    canvas.onwheel = (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        state.camera.zoom *= delta;
        render();
    };

    // --- –¢–ï–ö–°–¢–û–í–´–ï –§–£–ù–ö–¶–ò–ò ---
    function showTextInput(x, y, world, existing = null) {
        textInput.style.display = 'block';
        textInput.style.left = x + 'px';
        textInput.style.top = y + 'px';
        textInput.innerText = existing ? existing.data : '';
        state.textTarget = { world, existing };
        setTimeout(() => textInput.focus(), 10);
    }

    function editExistingText(obj, x, y) {
        showTextInput(x, y, {x: obj.x, y: obj.y}, obj);
    }

    textInput.onblur = () => {
        const val = textInput.innerText.trim();
        if (val) {
            if (state.textTarget.existing) {
                state.textTarget.existing.data = val;
            } else {
                state.objects.push({ type: 'text', x: state.textTarget.world.x, y: state.textTarget.world.y, w: 150, h: 30, data: val });
            }
        } else if (state.textTarget.existing) {
            state.objects = state.objects.filter(o => o !== state.textTarget.existing);
        }
        textInput.style.display = 'none';
        render();
    };

    // --- –°–õ–û–ò –ò –£–î–ê–õ–ï–ù–ò–ï ---
    function moveZ(dir) {
        if (!state.selectedObj) return;
        const idx = state.objects.indexOf(state.selectedObj);
        state.objects.splice(idx, 1);
        if (dir === 'up') state.objects.push(state.selectedObj);
        else state.objects.unshift(state.selectedObj);
        render();
    }

    function deleteSelected() {
        if (state.selectedObj) { state.objects = state.objects.filter(o => o !== state.selectedObj); state.selectedObj = null; render(); }
    }

    function clearBoard() { if (confirm("–°–±—Ä–æ—Å–∏—Ç—å –≤—Å—ë?")) { state.objects = []; state.lines = []; render(); } }

    function toggleTheme() {
        state.theme = state.theme === 'light' ? 'dark' : 'light';
        document.body.setAttribute('data-theme', state.theme);
        render();
    }

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(state.camera.x, state.camera.y);
        ctx.scale(state.camera.zoom, state.camera.zoom);

        state.objects.forEach(obj => {
            if (obj.type === 'image' || obj.type === 'video') {
                ctx.drawImage(obj.el, obj.x, obj.y, obj.w, obj.h);
            } else if (obj.type === 'text') {
                ctx.fillStyle = state.theme === 'light' ? '#000' : '#fff';
                ctx.font = "20px sans-serif";
                ctx.fillText(obj.data, obj.x, obj.y);
            }
            if (state.selectedObj === obj) {
                ctx.strokeStyle = '#007bff'; ctx.lineWidth = 2/state.camera.zoom;
                ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
                ctx.fillStyle = '#007bff';
                const s = 12/state.camera.zoom;
                ctx.fillRect(obj.x + obj.w - s, obj.y + obj.h - s, s, s);
            }
        });

        state.lines.forEach(line => {
            ctx.beginPath(); ctx.strokeStyle = line.color; ctx.lineWidth = 3/state.camera.zoom; ctx.lineCap = 'round';
            ctx.moveTo(line.points[0].x, line.points[0].y);
            line.points.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
        });
        ctx.restore();
        if (state.objects.some(o => o.type === 'video' && !o.el.paused)) requestAnimationFrame(render);
    }
    init();
</script>
</body>
</html>
