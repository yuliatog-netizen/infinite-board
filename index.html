<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Infinite Board PRO v2.3</title>
    <style>
        :root { --bg: #f0f0f0; --panel: #ffffff; --accent: #007bff; --text: #333; --danger: #dc3545; }
        [data-theme="dark"] { --bg: #1a1a1a; --panel: #333; --accent: #007bff; --text: #eee; }

        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: var(--bg); font-family: sans-serif; transition: 0.3s; touch-action: none; }
        
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; pointer-events: none; z-index: 100; display: flex; flex-direction: column; align-items: center; }
        .panel { 
            pointer-events: auto; background: var(--panel); padding: 5px 12px; 
            border-radius: 30px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
            display: flex; gap: 6px; align-items: center; margin: 8px;
            border: 1px solid rgba(0,0,0,0.1); flex-wrap: wrap; justify-content: center;
        }

        button { 
            background: #eee; border: none; padding: 6px 10px; border-radius: 15px; 
            cursor: pointer; font-size: 13px; transition: 0.2s; color: #333;
        }
        [data-theme="dark"] button { background: #444; color: #eee; }
        button.active { background: var(--accent) !important; color: white !important; }
        
        #canvas { display: block; }
        #text-input { position: fixed; display: none; background: white; border: 2px solid var(--accent); z-index: 1000; outline: none; padding: 5px; color: black; }
    </style>
</head>
<body data-theme="light">

<div id="ui-layer">
    <div class="panel">
        <button onclick="toggleTheme()">üåì</button>
        <button id="mode-move" class="active" onclick="setMode('move')">üñêÔ∏è</button>
        <button id="mode-draw" onclick="setMode('draw')">‚úèÔ∏è</button>
        <button id="mode-eraser" onclick="setMode('eraser')">üßΩ</button>
        <button id="mode-text" onclick="setMode('text')">TXT</button>
        <hr style="width:1px; height:20px; border:none; background:#ccc;">
        <button onclick="undo()">‚Ü©Ô∏è</button>
        <button onclick="redo()">‚Ü™Ô∏è</button>
        <hr style="width:1px; height:20px; border:none; background:#ccc;">
        <input type="file" id="file-input" hidden accept="image/*,video/*" onchange="handleFile(event)">
        <button onclick="document.getElementById('file-input').click()">‚ûï</button>
        <button id="snap-btn" onclick="takeSnapshot()" style="display:none;">üì∏ –ö–∞–¥—Ä</button>
        <button class="danger" onclick="deleteSelected()">üóëÔ∏è</button>
    </div>
</div>

<div id="text-input" contenteditable="true"></div>
<canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const textInput = document.getElementById('text-input');

    let state = {
        mode: 'move', theme: 'light',
        camera: { x: window.innerWidth/2, y: window.innerHeight/2, zoom: 1 },
        objects: [], lines: [],
        selectedObj: null,
        history: [], historyIdx: -1
    };

    function init() {
        window.addEventListener('resize', resize);
        window.addEventListener('keydown', handleKeys);
        resize();
        saveHistory(); // –ù–∞—á–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞
        render();
    }

    function handleKeys(e) {
        if (e.ctrlKey && e.code === 'KeyZ') { e.preventDefault(); undo(); }
        if (e.ctrlKey && e.code === 'KeyY') { e.preventDefault(); redo(); }
    }

    // --- –°–ò–°–¢–ï–ú–ê –ò–°–¢–û–†–ò–ò (Undo/Redo) ---
    function saveHistory() {
        // –£–¥–∞–ª—è–µ–º "–±—É–¥—É—â–µ–µ", –µ—Å–ª–∏ –º—ã —Å–¥–µ–ª–∞–ª–∏ –Ω–æ–≤–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ –ø–æ—Å–ª–µ Undo
        if (state.historyIdx < state.history.length - 1) {
            state.history = state.history.slice(0, state.historyIdx + 1);
        }
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–ø–∏—é –æ–±—ä–µ–∫—Ç–æ–≤
        const snapshot = JSON.stringify({ 
            objects: state.objects.map(o => ({...o, el: null})), // –ö–∞—Ä—Ç–∏–Ω–∫–∏ –Ω–µ —Å–µ—Ä–∏–∞–ª–∏–∑—É–µ–º
            lines: state.lines 
        });
        state.history.push(snapshot);
        if (state.history.length > 30) state.history.shift(); // –õ–∏–º–∏—Ç 30 —à–∞–≥–æ–≤
        state.historyIdx = state.history.length - 1;
    }

    function undo() {
        if (state.historyIdx > 0) {
            state.historyIdx--;
            applyHistory();
        }
    }

    function redo() {
        if (state.historyIdx < state.history.length - 1) {
            state.historyIdx++;
            applyHistory();
        }
    }

    function applyHistory() {
        const data = JSON.parse(state.history[state.historyIdx]);
        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ª–∏–Ω–∏–∏
        state.lines = data.lines;
        // –°–ª–æ–∂–Ω–∞—è —á–∞—Å—Ç—å: –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–±—ä–µ–∫—Ç—ã, —Å–æ—Ö—Ä–∞–Ω—è—è —Å—Å—ã–ª–∫–∏ –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç—ã (–∫–∞—Ä—Ç–∏–Ω–∫–∏/–≤–∏–¥–µ–æ)
        state.objects = data.objects.map(oldObj => {
            const existing = state.objects.find(o => o.type === oldObj.type && o.x === oldObj.x);
            return existing ? { ...oldObj, el: existing.el } : oldObj;
        });
        render();
    }

    // --- –§–£–ù–ö–¶–ò–ò –ú–ï–î–ò–ê ---
    function handleFile(e) {
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        const pos = { x: (window.innerWidth/2 - state.camera.x)/state.camera.zoom, y: (window.innerHeight/2 - state.camera.y)/state.camera.zoom };

        if (file.type.startsWith('image')) {
            const img = new Image(); img.src = url;
            img.onload = () => { addObj({ type: 'image', x: pos.x, y: pos.y, w: img.width/2, h: img.height/2, el: img, ratio: img.width/img.height }); };
        } else {
            const video = document.createElement('video'); video.src = url; video.muted = true; video.loop = true;
            video.onloadeddata = () => { addObj({ type: 'video', x: pos.x, y: pos.y, w: 320, h: 180, el: video, ratio: 320/180 }); };
        }
    }

    function addObj(obj) {
        state.objects.push(obj);
        saveHistory();
        render();
    }

    // –°–ö–†–ò–ù–®–û–¢ –í–ò–î–ï–û (–ö–∏–ª–ª–µ—Ä-—Ñ–∏—á–∞)
    function takeSnapshot() {
        if (state.selectedObj && state.selectedObj.type === 'video') {
            const video = state.selectedObj.el;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            tempCanvas.getContext('2d').drawImage(video, 0, 0);
            
            const img = new Image();
            img.src = tempCanvas.toDataURL('image/png');
            img.onload = () => {
                addObj({ 
                    type: 'image', x: state.selectedObj.x + 20, y: state.selectedObj.y + 20, 
                    w: state.selectedObj.w, h: state.selectedObj.h, el: img, ratio: state.selectedObj.ratio 
                });
            };
        }
    }

    // --- –û–°–ù–û–í–ù–û–ô –¶–ò–ö–õ ---
    function setMode(m) {
        state.mode = m;
        document.querySelectorAll('.panel button').forEach(b => b.classList.remove('active'));
        document.getElementById('mode-' + m).classList.add('active');
    }

    canvas.onpointerdown = (e) => {
        const mouse = { x: e.clientX, y: e.clientY };
        const world = { x: (mouse.x - state.camera.x)/state.camera.zoom, y: (mouse.y - state.camera.y)/state.camera.zoom };
        state.lastMouse = mouse;

        if (state.mode === 'draw' || state.mode === 'eraser') {
            state.isDrawing = true;
            if (state.mode === 'draw') state.lines.push({ points: [world], color: state.theme === 'light' ? '#000' : '#fff' });
            return;
        }

        const hit = [...state.objects].reverse().find(o => world.x > o.x && world.x < o.x + o.w && world.y > o.y && world.y < o.y + o.h);
        
        if (hit) {
            state.selectedObj = hit;
            state.isDragging = true;
            document.getElementById('snap-btn').style.display = (hit.type === 'video') ? 'inline-block' : 'none';
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ä–µ—Å–∞–π–∑ (–ø—Ä–∞–≤—ã–π –Ω–∏–∂–Ω–∏–π —É–≥–æ–ª)
            const s = 20 / state.camera.zoom;
            if (world.x > hit.x + hit.w - s && world.y > hit.y + hit.h - s) {
                state.isResizing = true;
                state.isDragging = false;
            } else if (hit.type === 'video') {
                hit.el.paused ? hit.el.play() : hit.el.pause();
            }
        } else {
            state.selectedObj = null;
            state.isDragging = true;
            document.getElementById('snap-btn').style.display = 'none';
        }
        render();
    };

    canvas.onpointermove = (e) => {
        const mouse = { x: e.clientX, y: e.clientY };
        const dx = (mouse.x - state.lastMouse.x) / state.camera.zoom;
        const dy = (mouse.y - state.lastMouse.y) / state.camera.zoom;
        const world = { x: (mouse.x - state.camera.x)/state.camera.zoom, y: (mouse.y - state.camera.y)/state.camera.zoom };

        if (state.isDrawing) {
            if (state.mode === 'draw') state.lines[state.lines.length-1].points.push(world);
            else state.lines = state.lines.filter(l => !l.points.some(p => Math.hypot(p.x-world.x, p.y-world.y) < 10/state.camera.zoom));
        } else if (state.isResizing && state.selectedObj) {
            state.selectedObj.w += dx;
            state.selectedObj.h = state.selectedObj.w / state.selectedObj.ratio;
        } else if (state.isDragging) {
            if (state.selectedObj && state.mode === 'move') {
                state.selectedObj.x += dx; state.selectedObj.y += dy;
            } else {
                state.camera.x += mouse.x - state.lastMouse.x;
                state.camera.y += mouse.y - state.lastMouse.y;
            }
        }
        state.lastMouse = mouse;
        render();
    };

    window.onpointerup = () => {
        if (state.isDrawing || state.isResizing || (state.isDragging && state.selectedObj)) saveHistory();
        state.isDrawing = state.isResizing = state.isDragging = false;
    };

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(state.camera.x, state.camera.y);
        ctx.scale(state.camera.zoom, state.camera.zoom);

        state.objects.forEach(obj => {
            if (obj.el) ctx.drawImage(obj.el, obj.x, obj.y, obj.w, obj.h);
            if (state.selectedObj === obj) {
                ctx.strokeStyle = '#007bff'; ctx.lineWidth = 2/state.camera.zoom; ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
                ctx.fillStyle = '#007bff'; const s = 10/state.camera.zoom; ctx.fillRect(obj.x+obj.w-s, obj.y+obj.h-s, s, s);
            }
        });

        state.lines.forEach(l => {
            ctx.beginPath(); ctx.strokeStyle = l.color; ctx.lineWidth = 3/state.camera.zoom; ctx.lineCap='round';
            ctx.moveTo(l.points[0].x, l.points[0].y);
            l.points.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
        });
        ctx.restore();
        if (state.objects.some(o => o.type === 'video' && !o.el.paused)) requestAnimationFrame(render);
    }

    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; render(); }
    function toggleTheme() { state.theme = state.theme === 'light' ? 'dark' : 'light'; document.body.setAttribute('data-theme', state.theme); render(); }
    function deleteSelected() { if(state.selectedObj) { state.objects = state.objects.filter(o=>o!==state.selectedObj); state.selectedObj=null; saveHistory(); render(); } }

    canvas.onwheel = (e) => { e.preventDefault(); state.camera.zoom *= (e.deltaY > 0 ? 0.9 : 1.1); render(); };
    init();
</script>
</body>
</html>
