<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Infinite Board (PureRef Style)</title>
<style>
  html, body { margin: 0; height: 100%; overflow: hidden; font-family: sans-serif; background: #1a1a1a; color: white; }
  #toolbar {
    position: fixed; top: 15px; left: 50%; transform: translateX(-50%);
    background: #333; padding: 10px 20px; border-radius: 30px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.5); z-index: 10;
    display: flex; gap: 15px; align-items: center; border: 1px solid #444;
  }
  canvas { display: block; }
  button { 
    background: #444; color: white; border: none; padding: 8px 15px; 
    border-radius: 20px; cursor: pointer; transition: 0.2s; 
  }
  button:hover { background: #555; }
  button.active { background: #007bff; }
  input[type="color"] { border: none; width: 30px; height: 30px; cursor: pointer; background: none; }
  .hint { position: fixed; bottom: 10px; right: 10px; color: #888; font-size: 12px; pointer-events: none; }
</style>
</head>
<body>

<div id="toolbar">
  <button onclick="openProject()">üìÇ –û—Ç–∫—Ä—ã—Ç—å JSON</button>
  <button onclick="saveProject()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
  <hr style="border: 0; border-left: 1px solid #555; height: 20px;">
  <input type="file" id="fileInput" style="display:none" accept="image/*,video/*" onchange="addMedia(event)">
  <button onclick="document.getElementById('fileInput').click()">‚ûï –ú–µ–¥–∏–∞</button>
  <button id="btn-draw" onclick="setMode('draw')">‚úèÔ∏è –†–∏—Å–æ–≤–∞—Ç—å</button>
  <button id="btn-move" onclick="setMode('move')" class="active">üñêÔ∏è –î–≤–∏–≥–∞—Ç—å</button>
  <input type="color" id="colorPicker" value="#ffffff" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏">
  <button onclick="clearBoard()" style="background: #600;">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å</button>
</div>

<div class="hint">–ö–æ–ª–µ—Å–æ –º—ã—à–∏: –ó—É–º | –ü—Ä–∞–≤–∞—è –∫–Ω–æ–ø–∫–∞: –£–¥–∞–ª–∏—Ç—å –æ–±—ä–µ–∫—Ç | –î–≤–∏–≥–∞—Ç—å: –ó–∞–∂–∞—Ç—å –ø—Ä–æ–±–µ–ª –∏–ª–∏ –∫–Ω–æ–ø–∫—É</div>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const colorPicker = document.getElementById('colorPicker');

let mode = 'move';
let objects = []; 
let lines = [];   
let isDrawing = false;
let isPanning = false;

// –°–æ—Å—Ç–æ—è–Ω–∏–µ –∫–∞–º–µ—Ä—ã
let camera = { x: window.innerWidth/2, y: window.innerHeight/2, zoom: 1 };
let lastMouse = { x: 0, y: 0 };
let fileHandle = null; // –î–ª—è "—É–º–Ω–æ–≥–æ" —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  render();
}
window.onresize = resize;
resize();

function setMode(m) {
  mode = m;
  document.querySelectorAll('#toolbar button').forEach(b => b.classList.remove('active'));
  const btn = document.getElementById('btn-' + m);
  if(btn) btn.classList.add('active');
}

// –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –º—ã—à–∏ —Å —É—á–µ—Ç–æ–º –∑—É–º–∞ –∏ –∫–∞–º–µ—Ä—ã
function getWorldPos(e) {
  return {
    x: (e.clientX - camera.x) / camera.zoom,
    y: (e.clientY - camera.y) / camera.zoom
  };
}

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const delta = e.deltaY > 0 ? 0.9 : 1.1;
  const mouseBefore = getWorldPos(e);
  camera.zoom *= delta;
  // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –∑—É–º–∞
  if (camera.zoom < 0.1) camera.zoom = 0.1;
  if (camera.zoom > 5) camera.zoom = 5;
  
  const mouseAfter = getWorldPos(e);
  camera.x += (mouseAfter.x - mouseBefore.x) * camera.zoom;
  camera.y += (mouseAfter.y - mouseBefore.y) * camera.zoom;
  render();
}, { passive: false });

canvas.addEventListener('pointerdown', e => {
  lastMouse = { x: e.clientX, y: e.clientY };
  const worldPos = getWorldPos(e);

  if (e.button === 2) { // –ü—Ä–∞–≤–∞—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏ ‚Äî —É–¥–∞–ª–µ–Ω–∏–µ
    objects = objects.filter(o => !(worldPos.x > o.x && worldPos.x < o.x + o.w && worldPos.y > o.y && worldPos.y < o.y + o.h));
    render();
    return;
  }

  if (mode === 'draw') {
    isDrawing = true;
    lines.push({ points: [worldPos], color: colorPicker.value });
  } else {
    isPanning = true;
  }
});

canvas.addEventListener('pointermove', e => {
  const worldPos = getWorldPos(e);
  if (isDrawing) {
    lines[lines.length - 1].points.push(worldPos);
    render();
  } else if (isPanning) {
    camera.x += e.clientX - lastMouse.x;
    camera.y += e.clientY - lastMouse.y;
    lastMouse = { x: e.clientX, y: e.clientY };
    render();
  }
});

window.addEventListener('pointerup', () => { isDrawing = false; isPanning = false; });
canvas.oncontextmenu = (e) => e.preventDefault();

function addMedia(e) {
  const file = e.target.files[0];
  if (!file) return;
  const url = URL.createObjectURL(file);
  const worldCenter = { x: -camera.x / camera.zoom, y: -camera.y / camera.zoom };
  
  if (file.type.startsWith('video')) {
    const video = document.createElement('video');
    video.src = url;
    video.muted = true;
    video.loop = true;
    video.play();
    objects.push({ type: 'video', el: video, x: worldCenter.x, y: worldCenter.y, w: 400, h: 225 });
    video.onloadeddata = render;
  } else {
    const img = new Image();
    img.src = url;
    img.onload = () => {
      objects.push({ type: 'image', el: img, x: worldCenter.x, y: worldCenter.y, w: img.width/2, h: img.height/2 });
      render();
    };
  }
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // –†–∏—Å—É–µ–º —Å–µ—Ç–∫—É
  drawGrid();

  ctx.save();
  ctx.translate(camera.x, camera.y);
  ctx.scale(camera.zoom, camera.zoom);

  objects.forEach(o => {
    ctx.drawImage(o.el, o.x, o.y, o.w, o.h);
    if (o.type === 'video') requestAnimationFrame(render); // –í–∏–¥–µ–æ –Ω—É–∂–Ω–æ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞—Ç—å
  });

  lines.forEach(line => {
    ctx.beginPath();
    ctx.strokeStyle = line.color;
    ctx.lineWidth = 2 / camera.zoom;
    ctx.lineCap = 'round';
    ctx.moveTo(line.points[0].x, line.points[0].y);
    line.points.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.stroke();
  });

  ctx.restore();
}

function drawGrid() {
  const size = 50 * camera.zoom;
  ctx.strokeStyle = '#2a2a2a';
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let x = camera.x % size; x < canvas.width; x += size) {
    ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height);
  }
  for (let y = camera.y % size; y < canvas.height; y += size) {
    ctx.moveTo(0, y); ctx.lineTo(canvas.width, y);
  }
  ctx.stroke();
}

function clearBoard() {
  if(confirm("–û—á–∏—Å—Ç–∏—Ç—å –≤—Å—é –¥–æ—Å–∫—É?")) {
    objects = []; lines = []; render();
  }
}

async function saveProject() {
  const data = JSON.stringify({ camera, lines, objects: [] }); // –û–±—ä–µ–∫—Ç—ã —Å URL —Å–ª–æ–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞
  
  try {
    if (!fileHandle) {
      fileHandle = await window.showSaveFilePicker({
        suggestedName: 'board.json',
        types: [{ description: 'JSON', accept: {'application/json': ['.json']} }]
      });
    }
    const writable = await fileHandle.createWritable();
    await writable.write(data);
    await writable.close();
    alert("–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ!");
  } catch (e) {
    console.error(e);
    // Fallback –µ—Å–ª–∏ –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç File System Access API
    const blob = new Blob([data], {type: 'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'board.json';
    a.click();
  }
}

async function openProject() {
  try {
    [fileHandle] = await window.showOpenFilePicker();
    const file = await fileHandle.getFile();
    const content = JSON.parse(await file.text());
    camera = content.camera;
    lines = content.lines;
    render();
  } catch (e) { alert("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏"); }
}
</script>
</body>
</html>
