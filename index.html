<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Infinite Board v4.4</title>
    <style>
        :root { --bg: #f0f0f0; --panel: #ffffff; --accent: #007bff; --text: #333; }
        [data-theme="dark"] { --bg: #1a1a1a; --panel: #333; --accent: #007bff; --text: #eee; }
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: var(--bg); font-family: sans-serif; }
        
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; pointer-events: none; z-index: 2000; display: flex; flex-direction: column; align-items: center; }
        .panel { pointer-events: auto; background: var(--panel); padding: 5px 12px; border-radius: 30px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); display: flex; gap: 6px; align-items: center; margin: 8px; border: 1px solid rgba(0,0,0,0.1); }
        
        #canvas-container { position: relative; width: 100%; height: 100%; }
        #canvas { position: absolute; inset: 0; z-index: 100; touch-action: none; background: transparent; }
        #dom-layer { position: absolute; inset: 0; z-index: 50; pointer-events: none; }
        
        .yt-wrapper { position: absolute; pointer-events: auto; background: #000; transition: none; }
        .yt-wrapper iframe { width: 100%; height: 100%; border: none; pointer-events: auto; }
        .yt-overlay { position: absolute; inset: 0; z-index: 10; cursor: move; display: none; }
        .mode-move .yt-overlay { display: block; }

        button { background: #eee; border: none; padding: 8px 12px; border-radius: 15px; cursor: pointer; font-weight: bold; }
        button.active { background: var(--accent) !important; color: white !important; }
        #login-screen { position: fixed; inset: 0; background: var(--bg); z-index: 3000; display: flex; justify-content: center; align-items: center; flex-direction: column; }
    </style>
</head>
<body>

<div id="login-screen">
    <h1>Infinite Board</h1>
    <button onclick="login()" style="padding: 15px 30px; background: #4285F4; color: white; border-radius: 10px;">–í–æ–π—Ç–∏ —á–µ—Ä–µ–∑ Google</button>
</div>

<div id="ui-layer" style="display:none;">
    <div class="panel">
        <button id="mode-move" class="active" onclick="setMode('move')">üñêÔ∏è</button>
        <button id="mode-draw" onclick="setMode('draw')">‚úèÔ∏è</button>
        <button id="mode-eraser" onclick="setMode('eraser')">üßΩ</button>
        <button onclick="resetCamera()">üéØ</button>
        <input type="file" id="file-input" hidden accept="image/*,video/*" onchange="handleFile(event)">
        <button onclick="document.getElementById('file-input').click()">‚ûï</button>
        <button onclick="addYouTube()" style="color:red">YT</button>
        <button onclick="deleteSelected()" style="color:red">üóëÔ∏è</button>
    </div>
    <div class="panel">
        <button onclick="undo()">‚Ü©Ô∏è</button>
        <button onclick="redo()">‚Ü™Ô∏è</button>
        <button onclick="toggleTheme()">üåì</button>
        <div id="status-dot" style="width:8px; height:8px; border-radius:50%; background: green;"></div>
    </div>
</div>

<div id="canvas-container">
    <canvas id="canvas"></canvas>
    <div id="dom-layer"></div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
    import { getFirestore, doc, onSnapshot, updateDoc, collection, addDoc, query, where, getDocs } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const app = initializeApp({
        apiKey: "AIzaSyAYZY3gBo7uT-MSmgXnsZn3Y_q2zzU4OAM",
        authDomain: "infiniteboard-3197d.firebaseapp.com",
        projectId: "infiniteboard-3197d",
        storageBucket: "infiniteboard-3197d.firebasestorage.app",
        appId: "1:786069509066:web:ab900d2d7c952195067533"
    });
    const auth = getAuth(app), db = getFirestore(app);

    let state = { mode: 'move', theme: 'light', camera: { x: window.innerWidth/2, y: window.innerHeight/2, zoom: 1 }, objects: [], lines: [], selectedObj: null };
    let currentUser = null, currentBoardId = null;

    // --- YT & CLOUDINARY ---
    window.addYouTube = () => {
        const url = prompt("–°—Å—ã–ª–∫–∞ –Ω–∞ YouTube:");
        const id = url?.match(/(?:youtu\.be\/|youtube\.com\/(?:.*v=|.*\/|.*embed\/))([^?&]+)/);
        if (id) {
            const pos = { x: (window.innerWidth/2 - state.camera.x)/state.camera.zoom, y: (window.innerHeight/2 - state.camera.y)/state.camera.zoom };
            state.objects.push({ type: 'youtube', x: pos.x, y: pos.y, w: 480, h: 270, ytId: id[1], ratio: 16/9 });
            triggerSave(); render();
        }
    };

    window.handleFile = async (e) => {
        const file = e.target.files[0]; if (!file) return;
        const formData = new FormData(); formData.append('file', file); formData.append('upload_preset', 'ml_default');
        const res = await fetch(`https://api.cloudinary.com/v1_1/dacvtrygp/auto/upload`, { method: 'POST', body: formData });
        const data = await res.json();
        const pos = { x: (window.innerWidth/2 - state.camera.x)/state.camera.zoom, y: (window.innerHeight/2 - state.camera.y)/state.camera.zoom };
        if (file.type.startsWith('image')) {
            const img = new Image(); img.src = data.secure_url;
            img.onload = () => { state.objects.push({ type: 'image', x: pos.x, y: pos.y, w: img.width/2, h: img.height/2, url: data.secure_url, ratio: img.width/img.height, el: img }); triggerSave(); render(); };
        } else {
            const vid = document.createElement('video'); vid.src = data.secure_url; vid.muted = true; vid.loop = true; vid.playsInline = true;
            vid.onloadedmetadata = () => { vid.currentTime = 0.1; state.objects.push({ type: 'video', x: pos.x, y: pos.y, w: 320, h: 320/(vid.videoWidth/vid.videoHeight), url: data.secure_url, ratio: vid.videoWidth/vid.videoHeight, el: vid }); triggerSave(); render(); };
        }
    };

    // --- CORE ---
    function syncObjects(data) {
        const dataIds = data.map(o => o.url || o.ytId);
        state.objects = state.objects.filter(o => {
            if (!dataIds.includes(o.url || o.ytId)) { if (o.dom) o.dom.remove(); return false; }
            return true;
        });
        data.forEach(obj => {
            let ex = state.objects.find(o => (o.url && o.url === obj.url) || (o.ytId && o.ytId === obj.ytId));
            if (ex) { Object.assign(ex, obj); }
            else {
                if (obj.type === 'youtube') {
                    const wrap = document.createElement('div'); wrap.className = 'yt-wrapper';
                    wrap.innerHTML = `<div class="yt-overlay"></div><iframe src="https://www.youtube.com/embed/${obj.ytId}"></iframe>`;
                    document.getElementById('dom-layer').appendChild(wrap);
                    obj.dom = wrap;
                } else if (obj.type === 'image') { obj.el = new Image(); obj.el.src = obj.url; }
                else if (obj.type === 'video') { obj.el = document.createElement('video'); obj.el.src = obj.url; obj.el.muted = true; obj.el.loop = true; obj.el.playsInline = true; obj.el.currentTime = 0.1; }
                state.objects.push(obj);
            }
        });
        render();
    }

    function triggerSave() {
        if (!currentBoardId) return;
        const toSave = state.objects.map(({el, dom, ...o}) => o);
        updateDoc(doc(db, "boards", currentBoardId), { objects: toSave, lines: state.lines });
    }

    const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; render(); }
    window.addEventListener('resize', resize); resize();

    canvas.addEventListener('pointerdown', e => {
        const m = { x: e.clientX, y: e.clientY };
        const w = { x: (m.x - state.camera.x)/state.camera.zoom, y: (m.y - state.camera.y)/state.camera.zoom };
        state.lastMouse = m;

        if (state.mode !== 'move') {
            state.isDrawing = true;
            if (state.mode === 'draw') state.lines.push({ points: [w], color: state.theme==='light'?'#000':'#fff' });
            return;
        }

        const hit = [...state.objects].reverse().find(o => w.x > o.x && w.x < o.x + o.w && w.y > o.y && w.y < o.y + o.h);
        state.selectedObj = hit;
        if (hit) {
            const s = 30 / state.camera.zoom;
            if (w.x > hit.x + hit.w - s && w.y > hit.y + hit.h - s) state.isResizing = true;
            else { state.isDragging = true; if(hit.el && hit.type==='video') hit.el.paused ? hit.el.play() : hit.el.pause(); }
        } else state.isDragging = true;
        render();
    });

    canvas.addEventListener('pointermove', e => {
        if (!state.lastMouse) return;
        const m = { x: e.clientX, y: e.clientY };
        const dx = (m.x - state.lastMouse.x)/state.camera.zoom;
        const dy = (m.y - state.lastMouse.y)/state.camera.zoom;
        const w = { x: (m.x - state.camera.x)/state.camera.zoom, y: (m.y - state.camera.y)/state.camera.zoom };

        if (state.isDrawing) {
            if (state.mode === 'draw') state.lines[state.lines.length-1].points.push(w);
            else state.lines = state.lines.filter(l => !l.points.some(p => Math.hypot(p.x-w.x, p.y-w.y)<20/state.camera.zoom));
        } else if (state.isResizing && state.selectedObj) {
            state.selectedObj.w += dx; state.selectedObj.h = state.selectedObj.w / (state.selectedObj.ratio || 1);
        } else if (state.isDragging) {
            if (state.selectedObj) { state.selectedObj.x += dx; state.selectedObj.y += dy; }
            else { state.camera.x += m.x - state.lastMouse.x; state.camera.y += m.y - state.lastMouse.y; }
        }
        state.lastMouse = m; render();
    });

    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const d = e.deltaY > 0 ? 0.9 : 1.1;
        const wX = (e.clientX - state.camera.x) / state.camera.zoom;
        const wY = (e.clientY - state.camera.y) / state.camera.zoom;
        state.camera.zoom *= d;
        state.camera.x = e.clientX - wX * state.camera.zoom;
        state.camera.y = e.clientY - wY * state.camera.zoom;
        render();
    }, { passive: false });

    window.addEventListener('pointerup', () => { if(state.isDragging || state.isResizing || state.isDrawing) triggerSave(); state.isDragging = state.isResizing = state.isDrawing = false; state.lastMouse = null; });

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // –°–µ—Ç–∫–∞ (—Ç–µ–ø–µ—Ä—å –≤—Å–µ–≥–¥–∞ —Å–Ω–∏–∑—É)
        const g = 50 * state.camera.zoom;
        ctx.beginPath(); ctx.strokeStyle = state.theme==='light'?'#ddd':'#222';
        for(let x=state.camera.x%g; x<canvas.width; x+=g){ ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
        for(let y=state.camera.y%g; y<canvas.height; y+=g){ ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
        ctx.stroke();

        ctx.save(); ctx.translate(state.camera.x, state.camera.y); ctx.scale(state.camera.zoom, state.camera.zoom);
        
        state.objects.forEach(obj => {
            if (obj.type === 'youtube' && obj.dom) {
                obj.dom.style.transform = `translate(${obj.x * state.camera.zoom + state.camera.x}px, ${obj.y * state.camera.zoom + state.camera.y}px) scale(${state.camera.zoom})`;
                obj.dom.style.transformOrigin = '0 0';
                obj.dom.style.width = `${obj.w}px`; obj.dom.style.height = `${obj.h}px`;
            } else if (obj.el) {
                ctx.drawImage(obj.el, obj.x, obj.y, obj.w, obj.h);
                if (obj.type === 'video' && obj.el.paused) {
                    const cx = obj.x + obj.w/2, cy = obj.y + obj.h/2, r = Math.min(obj.w, obj.h)*0.15;
                    ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(cx, cy, r, 0, 7); ctx.fill();
                    ctx.fillStyle = 'white'; ctx.beginPath(); ctx.moveTo(cx-r*0.3, cy-r*0.5); ctx.lineTo(cx+r*0.5, cy); ctx.lineTo(cx-r*0.3, cy+r*0.5); ctx.fill();
                }
            }
            if (state.selectedObj === obj) {
                ctx.strokeStyle = '#007bff'; ctx.lineWidth = 2/state.camera.zoom; ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
                ctx.fillStyle = '#007bff'; ctx.fillRect(obj.x + obj.w - 15/state.camera.zoom, obj.y + obj.h - 15/state.camera.zoom, 30/state.camera.zoom, 30/state.camera.zoom);
            }
        });
        
        state.lines.forEach(l => {
            ctx.beginPath(); ctx.strokeStyle = l.color; ctx.lineWidth = 3/state.camera.zoom; ctx.lineCap='round';
            l.points.forEach((p, i) => i ? ctx.lineTo(p.x, p.y) : ctx.moveTo(p.x, p.y)); ctx.stroke();
        });
        ctx.restore();
        if (state.objects.some(o => o.type === 'video' && o.el && !o.el.paused)) requestAnimationFrame(render);
    }

    // --- AUTH ---
    onAuthStateChanged(auth, async user => {
        if(user){
            currentUser = user; document.getElementById('login-screen').style.display='none'; document.getElementById('ui-layer').style.display='flex';
            const q = query(collection(db, "boards"), where("ownerId", "==", user.uid));
            const snap = await getDocs(q);
            if (snap.empty) {
                const ref = await addDoc(collection(db, "boards"), { name: "Main", ownerId: user.uid, objects: [], lines: [] });
                currentBoardId = ref.id;
            } else { currentBoardId = snap.docs[0].id; }
            onSnapshot(doc(db, "boards", currentBoardId), d => { if(d.exists() && !state.isDragging && !state.isResizing) syncObjects(d.data().objects || []); });
        }
    });
    window.login = () => signInWithPopup(auth, new GoogleAuthProvider());
    window.setMode = m => { state.mode = m; document.body.className = 'mode-'+m; document.querySelectorAll('.panel button').forEach(b => b.classList.toggle('active', b.id === 'mode-'+m)); };
    window.resetCamera = () => { state.camera = { x: window.innerWidth/2, y: window.innerHeight/2, zoom: 1 }; render(); };
    window.deleteSelected = () => { if(state.selectedObj){ if(state.selectedObj.dom) state.selectedObj.dom.remove(); state.objects = state.objects.filter(o => o !== state.selectedObj); state.selectedObj = null; triggerSave(); render(); } };
</script>
</body>
</html>
