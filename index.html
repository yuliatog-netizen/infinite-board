<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Infinite Board PRO</title>
    <style>
        :root { --bg: #f0f0f0; --panel: #ffffff; --accent: #007bff; --text: #333; }
        [data-theme="dark"] { --bg: #1a1a1a; --panel: #333; --accent: #007bff; --text: #eee; }

        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: var(--bg); font-family: 'Segoe UI', sans-serif; transition: 0.3s; }
        
        /* –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; pointer-events: none; z-index: 100; }
        .panel { 
            pointer-events: auto; background: var(--panel); padding: 10px; 
            border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
            display: flex; gap: 10px; align-items: center; margin: 10px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        #top-bar { position: absolute; left: 50%; transform: translateX(-50%); }
        #side-bar { position: absolute; left: 0; top: 60px; flex-direction: column; }

        button { 
            background: #eee; border: none; padding: 10px; border-radius: 10px; 
            cursor: pointer; font-size: 16px; transition: 0.2s; color: #333;
        }
        [data-theme="dark"] button { background: #444; color: #eee; }
        button.active { background: var(--accent) !important; color: white !important; }
        
        canvas { display: block; touch-action: none; }

        /* –¢–µ–∫—Å—Ç–æ–≤—ã–π —Ä–µ–¥–∞–∫—Ç–æ—Ä –ø–æ–≤–µ—Ä—Ö –∫–∞–Ω–≤–∞—Å–∞ */
        #text-editor {
            position: fixed; display: none; background: white; border: 2px solid var(--accent);
            z-index: 1000; outline: none; padding: 5px; min-width: 50px; color: black;
        }
    </style>
</head>
<body data-theme="light">

<div id="ui-layer">
    <div id="top-bar" class="panel">
        <button onclick="toggleTheme()">üåì</button>
        <button id="mode-move" class="active" onclick="setMode('move')">üñêÔ∏è</button>
        <button id="mode-draw" onclick="setMode('draw')">‚úèÔ∏è</button>
        <button id="mode-text" onclick="setMode('text')">TXT</button>
        <hr style="width:1px; height:20px; border:none; background:#ccc;">
        <input type="file" id="file-input" hidden accept="image/*,video/*" onchange="handleFile(event)">
        <button onclick="document.getElementById('file-input').click()">‚ûï</button>
        <button onclick="saveToJSON()">üíæ</button>
    </div>
    
    <div id="side-bar" class="panel">
        <button onclick="addBoard()">üìÅ –ù–æ–≤–∞—è –¥–æ—Å–∫–∞</button>
        <div id="boards-list"></div>
    </div>
</div>

<div id="text-editor" contenteditable="true"></div>
<canvas id="mainCanvas"></canvas>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const editor = document.getElementById('text-editor');

    let state = {
        mode: 'move',
        theme: 'light',
        camera: { x: window.innerWidth/2, y: window.innerHeight/2, zoom: 1 },
        objects: [], // { type: 'img/video/text', x, y, w, h, data: src/text }
        selectedObj: null,
        isDragging: false,
        lastMouse: { x: 0, y: 0 }
    };

    function init() {
        window.addEventListener('resize', resize);
        resize();
        loadFromLocalStorage();
        render();
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        render();
    }

    function setMode(m) {
        state.mode = m;
        document.querySelectorAll('.panel button').forEach(b => b.classList.remove('active'));
        document.getElementById('mode-' + m).classList.add('active');
    }

    // --- –õ–û–ì–ò–ö–ê –û–ë–™–ï–ö–¢–û–í ---
    function handleFile(e) {
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        const worldPos = { x: -state.camera.x / state.camera.zoom, y: -state.camera.y / state.camera.zoom };

        if (file.type.startsWith('image')) {
            const img = new Image();
            img.src = url;
            img.onload = () => {
                state.objects.push({ type: 'image', x: worldPos.x, y: worldPos.y, w: img.width/2, h: img.height/2, el: img });
                saveAndRender();
            };
        } else if (file.type.startsWith('video')) {
            const video = document.createElement('video');
            video.src = url; video.muted = true; video.loop = true; video.play();
            state.objects.push({ type: 'video', x: worldPos.x, y: worldPos.y, w: 320, h: 180, el: video });
            video.onloadeddata = saveAndRender;
        }
    }

    // --- –†–ï–ù–î–ï–†–ò–ù–ì ---
    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();

        ctx.save();
        ctx.translate(state.camera.x, state.camera.y);
        ctx.scale(state.camera.zoom, state.camera.zoom);

        state.objects.forEach(obj => {
            if (obj.type === 'image' || obj.type === 'video') {
                ctx.drawImage(obj.el, obj.x, obj.y, obj.w, obj.h);
            } else if (obj.type === 'text') {
                ctx.fillStyle = state.theme === 'light' ? '#000' : '#fff';
                ctx.font = "20px Arial";
                ctx.fillText(obj.data, obj.x, obj.y);
            }
            
            // –†–∞–º–∫–∞ –≤—ã–¥–µ–ª–µ–Ω–∏—è
            if (state.selectedObj === obj) {
                ctx.strokeStyle = '#007bff';
                ctx.lineWidth = 2 / state.camera.zoom;
                ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
            }
        });

        ctx.restore();
        if (state.objects.some(o => o.type === 'video')) requestAnimationFrame(render);
    }

    function drawGrid() {
        const size = 50 * state.camera.zoom;
        ctx.strokeStyle = state.theme === 'light' ? '#ddd' : '#333';
        ctx.beginPath();
        for (let x = state.camera.x % size; x < canvas.width; x += size) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
        for (let y = state.camera.y % size; y < canvas.height; y += size) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
        ctx.stroke();
    }

    // --- –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–ï ---
    canvas.onpointerdown = (e) => {
        state.isDragging = true;
        state.lastMouse = { x: e.clientX, y: e.clientY };
        
        const worldPos = {
            x: (e.clientX - state.camera.x) / state.camera.zoom,
            y: (e.clientY - state.camera.y) / state.camera.zoom
        };

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª–∏–∫–∞ –ø–æ –æ–±—ä–µ–∫—Ç—É
        state.selectedObj = [...state.objects].reverse().find(o => 
            worldPos.x > o.x && worldPos.x < o.x + o.w && worldPos.y > o.y && worldPos.y < o.y + o.h
        );

        if (state.mode === 'text' && !state.selectedObj) {
            showTextEditor(e.clientX, e.clientY, worldPos);
        }
        render();
    };

    canvas.onpointermove = (e) => {
        if (!state.isDragging) return;
        const dx = (e.clientX - state.lastMouse.x) / state.camera.zoom;
        const dy = (e.clientY - state.lastMouse.y) / state.camera.zoom;

        if (state.selectedObj && state.mode === 'move') {
            state.selectedObj.x += dx;
            state.selectedObj.y += dy;
        } else if (state.mode === 'move') {
            state.camera.x += e.clientX - state.lastMouse.x;
            state.camera.y += e.clientY - state.lastMouse.y;
        }
        state.lastMouse = { x: e.clientX, y: e.clientY };
        render();
    };

    window.onpointerup = () => { state.isDragging = false; saveToLocalStorage(); };

    // –ó—É–º
    canvas.onwheel = (e) => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        state.camera.zoom *= factor;
        render();
    };

    // --- –§–£–ù–ö–¶–ò–ò –¢–ï–ö–°–¢–ê ---
    function showTextEditor(screenX, screenY, worldPos) {
        editor.style.display = 'block';
        editor.style.left = screenX + 'px';
        editor.style.top = screenY + 'px';
        editor.focus();
        editor.onblur = () => {
            if (editor.innerText.trim()) {
                state.objects.push({ 
                    type: 'text', x: worldPos.x, y: worldPos.y, 
                    w: 100, h: 30, data: editor.innerText 
                });
            }
            editor.style.display = 'none';
            editor.innerText = '';
            saveAndRender();
        };
    }

    // --- –°–û–•–†–ê–ù–ï–ù–ò–ï ---
    function saveAndRender() { saveToLocalStorage(); render(); }

    function saveToLocalStorage() {
        const rawObjects = state.objects.map(o => ({...o, el: null})); // –ö–∞—Ä—Ç–∏–Ω–∫–∏ –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ JSON –Ω–∞–ø—Ä—è–º—É—é
        localStorage.setItem('infinite_board_data', JSON.stringify({
            camera: state.camera,
            objects: rawObjects.filter(o => o.type === 'text') // –ü–æ–∫–∞ —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç, –∫–∞—Ä—Ç–∏–Ω–∫–∏ —Ç—Ä–µ–±—É—é—Ç IndexedDB
        }));
    }

    function loadFromLocalStorage() {
        const data = localStorage.getItem('infinite_board_data');
        if (data) {
            const parsed = JSON.parse(data);
            state.camera = parsed.camera;
            // –ó–¥–µ—Å—å –±—É–¥–µ—Ç –ª–æ–≥–∏–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–∞—Ä—Ç–∏–Ω–æ–∫
        }
    }

    function toggleTheme() {
        state.theme = state.theme === 'light' ? 'dark' : 'light';
        document.body.setAttribute('data-theme', state.theme);
        render();
    }

    init();
</script>
</body>
</html>
